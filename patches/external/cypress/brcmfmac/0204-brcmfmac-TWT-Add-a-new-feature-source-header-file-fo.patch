From b91c7088276e518b2bafb8b42fd9d677ac75c88e Mon Sep 17 00:00:00 2001
From: Gokul Sivakumar <gokulkumar.sivakumar@infineon.com>
Date: Fri, 19 May 2023 00:27:50 -0500
Subject: [PATCH 204/208] brcmfmac: TWT: Add a new feature source & header file
 for Target Wake Time

Refactor and move all TWT functionality to a new TWT feature source and
header file. And rename some of thee enum, struct and functions to maintain
consistency across the source files.

Introduce a new dedicated TWT debug level (0x400000) to selectively enable
or disable the debug prints from the TWT feature source file.

Add a firmware feature flag with enum ID 27 for TWT and set it when the TWT
iovar is supported by Firmware. This new feature flag can be used to do the
appropriate TWT operations only with the Chip that supports it.

Update a detailed description for all the TWT enum, struct and function
available in the TWT feature source and header file.

Process the TWT Operation requests passed from userspace on a STA interface
only when the interface is associated with another WLAN device. Verify this
by checking the sme_state flag in struct brcmf_cfg80211_vif of an interface
is set to BRCMF_VIF_STATUS_CONNECTED.

Validate the Flow IDs and Negotiation types in the TWT setup and Teardown
request passed from userspace for an interface.


Signed-off-by: Gokul Sivakumar <gokulkumar.sivakumar@infineon.com>
---
 .../broadcom/brcm80211/brcmfmac/Makefile      |   3 +-
 .../broadcom/brcm80211/brcmfmac/debug.h       |   1 +
 .../broadcom/brcm80211/brcmfmac/feature.c     |   1 +
 .../broadcom/brcm80211/brcmfmac/feature.h     |   4 +-
 .../broadcom/brcm80211/brcmfmac/twt.c         | 359 ++++++++++++++++++
 .../broadcom/brcm80211/brcmfmac/twt.h         | 242 ++++++++++++
 .../broadcom/brcm80211/brcmfmac/vendor_ifx.c  | 255 ++-----------
 .../broadcom/brcm80211/brcmfmac/vendor_ifx.h  | 100 -----
 8 files changed, 635 insertions(+), 330 deletions(-)
 create mode 100644 drivers/net/wireless/broadcom/brcm80211/brcmfmac/twt.c
 create mode 100644 drivers/net/wireless/broadcom/brcm80211/brcmfmac/twt.h

diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/Makefile b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/Makefile
index 96e4b7a402c5..2fa8e6d1926e 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/Makefile
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/Makefile
@@ -25,7 +25,8 @@ brcmfmac-objs += \
 		vendor.o \
 		pno.o \
 		xtlv.o \
-		vendor_ifx.o
+		vendor_ifx.o \
+		twt.o
 brcmfmac-$(CONFIG_BRCMFMAC_PROTO_BCDC) += \
 		bcdc.o \
 		fwsignal.o
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
index d536bb99acc2..3e8f11b5db06 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
@@ -30,6 +30,7 @@
 #define BRCMF_PCIE_VAL		0x00080000
 #define BRCMF_FWCON_VAL		0x00100000
 #define BRCMF_ULP_VAL		0x00200000
+#define BRCMF_TWT_VAL		0x00400000
 
 /* set default print format */
 #undef pr_fmt
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
index a2547326c56c..d21575e833f3 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
@@ -292,6 +292,7 @@ void brcmf_feat_attach(struct brcmf_pub *drvr)
 		ifp->drvr->feat_flags |= BIT(BRCMF_FEAT_SCAN_RANDOM_MAC);
 
 	brcmf_feat_iovar_int_get(ifp, BRCMF_FEAT_FWSUP, "sup_wpa");
+	brcmf_feat_iovar_int_get(ifp, BRCMF_FEAT_TWT, "twt");
 
 	if (drvr->settings->feature_disable) {
 		brcmf_dbg(INFO, "Features: 0x%02x, disable: 0x%02x\n",
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
index 676f3ef5b8b7..3c802ad36a98 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
@@ -32,6 +32,7 @@
  * DUMP_OBSS: Firmware has capable to dump obss info to support ACS
  * SAE_EXT: SAE be handled by userspace supplicant
  * GCMP: firmware has defined GCMP or not.
+ * TWT: Firmware has the TWT Module Support.
  */
 #define BRCMF_FEAT_LIST \
 	BRCMF_FEAT_DEF(MBSS) \
@@ -59,7 +60,8 @@
 	BRCMF_FEAT_DEF(SAE_EXT) \
 	BRCMF_FEAT_DEF(FBT) \
 	BRCMF_FEAT_DEF(OKC) \
-	BRCMF_FEAT_DEF(GCMP)
+	BRCMF_FEAT_DEF(GCMP) \
+	BRCMF_FEAT_DEF(TWT)
 
 /*
  * Quirks:
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/twt.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/twt.c
new file mode 100644
index 000000000000..edf9cba2f8fb
--- /dev/null
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/twt.c
@@ -0,0 +1,359 @@
+/* Infineon WLAN driver: Target Wake Time (TWT) Source
+ *
+ * Copyright 2023 Cypress Semiconductor Corporation (an Infineon company)
+ * or an affiliate of Cypress Semiconductor Corporation. All rights reserved.
+ * This software, including source code, documentation and related materials
+ * ("Software") is owned by Cypress Semiconductor Corporation or one of its
+ * affiliates ("Cypress") and is protected by and subject to
+ * worldwide patent protection (United States and foreign),
+ * United States copyright laws and international treaty provisions.
+ * Therefore, you may use this Software only as provided in the license agreement
+ * accompanying the software package from which you obtained this Software ("EULA").
+ * If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
+ * non-transferable license to copy, modify, and compile the Software source code
+ * solely for use in connection with Cypress's integrated circuit products.
+ * Any reproduction, modification, translation, compilation, or representation
+ * of this Software except as specified above is prohibited without
+ * the expresswritten permission of Cypress.
+ * Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ * Cypress reserves the right to make changes to the Software without notice.
+ * Cypress does not assume any liability arising out of the application or
+ * use of the Software or any product or circuit described in the Software.
+ * Cypress does not authorize its products for use in any products where a malfunction
+ * or failure of the Cypress product may reasonably be expected to result in
+ * significant property damage, injury or death ("High Risk Product").
+ * By including Cypress's product in a High Risk Product, the manufacturer
+ * of such system or application assumes all risk of such use and in doing so
+ * agrees to indemnify Cypress against all liability.
+ */
+
+#include "twt.h"
+#include "debug.h"
+#include "fwil.h"
+#include "feature.h"
+#include "bus.h"
+#include "cfg80211.h"
+
+/**
+ * brcmf_twt_min_twt_to_wake_dur() - Derive Wake Duration from the
+ * 	Nominal Minimum Wake Duration
+ *
+ * @min_twt: Nominal Minimum Wake Duration input.
+ * @min_twt_unit: Nomial Minimum Wake Duration Unit input.
+ *	0 - 256 uS
+ * 	1 - 1TU (or) 1024 uS
+ *
+ * return: Wake Duration in unit of microseconds.
+ */
+static inline u32
+brcmf_twt_min_twt_to_wake_dur(u8 min_twt, u8 min_twt_unit)
+{
+	u32 wake_dur;
+
+	if (min_twt_unit) {
+		/*
+		 * If min_twt_unit is 1, then min_twt is
+		 * in units of TUs (i.e) 1024 uS.
+		 */
+		wake_dur = (u32)min_twt * WAKE_DUR_UNIT_TU;
+	} else {
+		/*
+		 * If min_twt_unit is 0, then min_twt is
+		 * in units of 256 uS.
+		 */
+		wake_dur = (u32)min_twt * WAKE_DUR_UNIT_DEF;
+	}
+
+	return wake_dur;
+}
+
+/**
+ * brcmf_twt_float_to_u32() - Derive Wake Interval derivation from
+ *	Wake Interval Mantissa & Exponent.
+ *
+ * @exponent: Wake Interval Exponent input.
+ * @mantissa: Wake Interval Mantissa input.
+ *
+ * return: Wake interval in unit of microseconds.
+ */
+static inline u32
+brcmf_twt_float_to_u32(u8 exponent, u16 mantissa)
+{
+	return (u32)mantissa << exponent;
+}
+
+/**
+ * brcmf_twt_setup_oper_handler() - Handle the TWT Setup Operation request from Userspace.
+ *
+ * @ifp: interface instance.
+ * @twt_params: TWT session parameters.
+ *
+ * return: 0 on success, value < 0 on failure.
+ */
+s32
+brcmf_twt_setup_oper_handler(struct brcmf_if *ifp, struct brcmf_twt_params twt_params)
+{
+	struct brcmf_twt_setup_oper val;
+	s32 ret;
+
+	memset(&val, 0, sizeof(val));
+	val.version = BRCMF_TWT_SETUP_VER;
+	val.length = sizeof(val.version) + sizeof(val.length);
+
+	/* Default values, Override Below */
+	val.sdesc.flow_flags = 0x0;
+	val.sdesc.wake_dur = 0xFFFFFFFF;
+	val.sdesc.wake_int = 0xFFFFFFFF;
+	val.sdesc.wake_int_max = 0xFFFFFFFF;
+
+	/* TWT Negotiation_type */
+	val.sdesc.negotiation_type = (u8)twt_params.negotiation_type;
+
+	switch (val.sdesc.negotiation_type) {
+	case IFX_TWT_PARAM_NEGO_TYPE_ITWT:
+		/* Flow ID */
+		if ((twt_params.flow_id >= 0x0 && twt_params.flow_id <= 0x7)) {
+			val.sdesc.flow_id = twt_params.flow_id;
+		} else if (twt_params.flow_id == 0xFF) {
+			/* Let the Firmware choose the Flow ID */
+			val.sdesc.flow_id = twt_params.flow_id;
+		} else {
+			brcmf_err("TWT: Setup REQ: flow ID: %d is invalid",
+				  twt_params.flow_id);
+			ret = -EINVAL;
+			goto exit;
+		}
+		break;
+	case IFX_TWT_PARAM_NEGO_TYPE_BTWT:
+		/* Broadcast TWT ID */
+		val.sdesc.bid = twt_params.bcast_twt_id;
+
+		/* TODO: Handle the Broadcast TWT Setup REQ */
+		/* FALLTHRU */
+	default:
+		brcmf_err("TWT: Setup REQ: Negotiation Type %d not handled",
+			  twt_params.negotiation_type);
+		ret = -EOPNOTSUPP;
+		goto exit;
+	}
+
+	/* Setup command */
+	val.sdesc.setup_cmd = twt_params.setup_cmd;
+
+	/* Flow flags */
+	val.sdesc.flow_flags |= ((twt_params.negotiation_type & 0x02) >> 1 ?
+				 BRCMF_TWT_FLOW_FLAG_BROADCAST : 0);
+	val.sdesc.flow_flags |= (twt_params.implicit ? BRCMF_TWT_FLOW_FLAG_IMPLICIT : 0);
+	val.sdesc.flow_flags |= (twt_params.flow_type ? BRCMF_TWT_FLOW_FLAG_UNANNOUNCED : 0);
+	val.sdesc.flow_flags |= (twt_params.trigger ? BRCMF_TWT_FLOW_FLAG_TRIGGER : 0);
+	val.sdesc.flow_flags |= ((twt_params.negotiation_type & 0x01) ?
+				 BRCMF_TWT_FLOW_FLAG_WAKE_TBTT_NEGO : 0);
+	val.sdesc.flow_flags |= (twt_params.requestor ? BRCMF_TWT_FLOW_FLAG_REQUEST : 0);
+	val.sdesc.flow_flags |= (twt_params.protection ? BRCMF_TWT_FLOW_FLAG_PROTECT : 0);
+
+	if (twt_params.twt) {
+		/* Target Wake Time parameter */
+		val.sdesc.wake_time_h = cpu_to_le32((u32)(twt_params.twt >> 32));
+		val.sdesc.wake_time_l = cpu_to_le32((u32)(twt_params.twt));
+		val.sdesc.wake_type = BRCMF_TWT_WAKE_TIME_TYPE_BSS;
+	} else if (twt_params.twt_offset) {
+		/* Target Wake Time offset parameter */
+		val.sdesc.wake_time_h = cpu_to_le32((u32)(twt_params.twt_offset >> 32));
+		val.sdesc.wake_time_l = cpu_to_le32((u32)(twt_params.twt_offset));
+		val.sdesc.wake_type = BRCMF_TWT_WAKE_TIME_TYPE_OFFSET;
+	} else {
+		/* Let the Firmware choose the Target Wake Time */
+		val.sdesc.wake_time_h = 0x0;
+		val.sdesc.wake_time_l = 0x0;
+		val.sdesc.wake_type = BRCMF_TWT_WAKE_TIME_TYPE_AUTO;
+	}
+
+	/* Wake Duration or Service Period */
+	val.sdesc.wake_dur = cpu_to_le32(brcmf_twt_min_twt_to_wake_dur(twt_params.min_twt,
+								      twt_params.min_twt_unit));
+
+	/* Wake Interval or Service Interval */
+	val.sdesc.wake_int = cpu_to_le32(brcmf_twt_float_to_u32(twt_params.exponent,
+							       twt_params.mantissa));
+
+	/* Send the TWT Setup request to Firmware */
+	ret = brcmf_fil_xtlv_data_set(ifp, "twt", BRCMF_TWT_CMD_SETUP,
+				      (void *)&val, sizeof(val));
+	if (ret < 0) {
+		brcmf_err("TWT: Setup REQ: Failed, ret: %d", ret);
+		goto exit;
+	}
+
+	brcmf_dbg(TWT, "TWT: Setup REQ: Initiated\n"
+		  "Setup command	: %u\n"
+		  "Flow flags		: 0x %02x\n"
+		  "Flow ID		: %u\n"
+		  "Broadcast TWT ID	: %u\n"
+		  "Wake Time H,L	: 0x %08x %08x\n"
+		  "Wake Type		: %u\n"
+		  "Wake Duration	: %u uS\n"
+		  "Wake Interval	: %u uS\n"
+		  "Negotiation type	: %u\n",
+		  val.sdesc.setup_cmd,
+		  val.sdesc.flow_flags,
+		  val.sdesc.flow_id,
+		  val.sdesc.bid,
+		  val.sdesc.wake_time_h,
+		  val.sdesc.wake_time_l,
+		  val.sdesc.wake_type,
+		  val.sdesc.wake_dur,
+		  val.sdesc.wake_int,
+		  val.sdesc.negotiation_type);
+exit:
+	return ret;
+}
+
+/**
+ * brcmf_twt_teardown_oper_handler() - Handle the TWT Teardown Operation request from Userspace.
+ *
+ * @ifp: interface instance.
+ * @twt_params: TWT session parameters.
+ *
+ * return: 0 on success, value < 0 on failure.
+ */
+s32
+brcmf_twt_teardown_oper_handler(struct brcmf_if *ifp, struct brcmf_twt_params twt_params)
+{
+	struct brcmf_twt_teardown_oper val;
+	s32 ret;
+
+	memset(&val, 0, sizeof(val));
+	val.version = BRCMF_TWT_TEARDOWN_VER;
+	val.length = sizeof(val.version) + sizeof(val.length);
+
+	/* TWT Negotiation_type */
+	val.teardesc.negotiation_type = (u8)twt_params.negotiation_type;
+
+	/* Teardown All TWT */
+	val.teardesc.alltwt = twt_params.teardown_all_twt;
+	if (val.teardesc.alltwt) {
+		/* Reset Flow ID & Bcast TWT ID with a placeholder value */
+		twt_params.flow_id = 0xFF;
+		twt_params.bcast_twt_id = 0xFF;
+	}
+
+	switch (val.teardesc.negotiation_type) {
+	case IFX_TWT_PARAM_NEGO_TYPE_ITWT:
+		/* Flow ID */
+		if ((twt_params.flow_id >= 0x0 && twt_params.flow_id <= 0x7)) {
+			val.teardesc.flow_id = twt_params.flow_id;
+		} else if (twt_params.flow_id == 0xFF) {
+			val.teardesc.flow_id = twt_params.flow_id;
+		} else {
+			brcmf_err("TWT: Teardown REQ: flow ID: %d is invalid",
+				  twt_params.flow_id);
+			ret = -EINVAL;
+			goto exit;
+		}
+		break;
+	case IFX_TWT_PARAM_NEGO_TYPE_BTWT:
+		/* Broadcast TWT ID */
+		val.teardesc.bid = twt_params.bcast_twt_id;
+
+		/* TODO: Handle the Broadcast TWT Teardown REQ */
+		/* FALLTHRU */
+	default:
+		brcmf_err("TWT: Teardown REQ: Negotiation Type %d not handled",
+			  twt_params.negotiation_type);
+		ret = -EOPNOTSUPP;
+		goto exit;
+	}
+
+	/* Send the TWT Teardown request to Firmware */
+	ret = brcmf_fil_xtlv_data_set(ifp, "twt", BRCMF_TWT_CMD_TEARDOWN,
+				      (void *)&val, sizeof(val));
+	if (ret < 0) {
+		brcmf_err("TWT: Teardown REQ: Failed, ret: %d", ret);
+		goto exit;
+	}
+
+	brcmf_dbg(TWT, "TWT: Teardown REQ: Initiated\n"
+		  "Flow ID		: %u\n"
+		  "Broadcast TWT ID	: %u\n"
+		  "Negotiation type	: %u\n"
+		  "Teardown all TWT	: %u\n",
+		  val.teardesc.flow_id,
+		  val.teardesc.bid,
+		  val.teardesc.negotiation_type,
+		  val.teardesc.alltwt);
+exit:
+	return ret;
+}
+
+/**
+ * brcmf_twt_oper() - Handle the TWT Operation requests from Userspace.
+ *
+ * @wiphy: wiphy object for cfg80211 interface.
+ * @wdev: wireless device.
+ * @twt_params: TWT session parameters.
+ *
+ * return: 0 on success, value < 0 on failure.
+ */
+s32
+brcmf_twt_oper(struct wiphy *wiphy, struct wireless_dev *wdev,
+	       struct brcmf_twt_params twt_params)
+{
+	struct brcmf_cfg80211_vif *vif = NULL;
+	struct brcmf_if *ifp = NULL;
+	s32 ret;
+
+	vif = wdev_to_vif(wdev);
+	if (!vif) {
+		ret = -EIO;
+		goto exit;
+	}
+
+	ifp = vif->ifp;
+	if (!ifp) {
+		ret = -EIO;
+		goto exit;
+	}
+
+	/* Check if TWT feature is supported in the Firmware */
+	if (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_TWT)) {
+		brcmf_err("TWT: REQ: Operation %d can't be handled, TWT not enabled",
+			  twt_params.twt_oper);
+		ret = -EOPNOTSUPP;
+		goto exit;
+	}
+
+	/* Check if vif is operating in Station Mode */
+	if (wdev->iftype != NL80211_IFTYPE_STATION) {
+		brcmf_err("TWT: REQ: Operation %d can't be handled, vif is not STA",
+			  twt_params.twt_oper);
+		ret = -EOPNOTSUPP;
+		goto exit;
+	}
+
+	/* Check if the interface is associated with another WLAN device */
+	if (!test_bit(BRCMF_VIF_STATUS_CONNECTED, &vif->sme_state)) {
+		brcmf_err("TWT: REQ: Operation %d can't be handled, vif not connected with WLAN peer",
+			  twt_params.twt_oper);
+		ret = -ENOTCONN;
+		goto exit;
+	}
+
+	/* TWT Operation */
+	switch (twt_params.twt_oper) {
+		case IFX_TWT_OPER_SETUP:
+			ret = brcmf_twt_setup_oper_handler(ifp, twt_params);
+			break;
+		case IFX_TWT_OPER_TEARDOWN:
+			ret = brcmf_twt_teardown_oper_handler(ifp, twt_params);
+			break;
+		default:
+			brcmf_err("TWT: REQ: Operation %d not supported",
+				  twt_params.twt_oper);
+			ret = -EOPNOTSUPP;
+			goto exit;
+	}
+exit:
+	return ret;
+}
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/twt.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/twt.h
new file mode 100644
index 000000000000..159bc3cb173e
--- /dev/null
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/twt.h
@@ -0,0 +1,242 @@
+/* Infineon WLAN driver: Target Wake Time (TWT) Header
+ *
+ * Copyright 2023 Cypress Semiconductor Corporation (an Infineon company)
+ * or an affiliate of Cypress Semiconductor Corporation. All rights reserved.
+ * This software, including source code, documentation and related materials
+ * ("Software") is owned by Cypress Semiconductor Corporation or one of its
+ * affiliates ("Cypress") and is protected by and subject to
+ * worldwide patent protection (United States and foreign),
+ * United States copyright laws and international treaty provisions.
+ * Therefore, you may use this Software only as provided in the license agreement
+ * accompanying the software package from which you obtained this Software ("EULA").
+ * If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
+ * non-transferable license to copy, modify, and compile the Software source code
+ * solely for use in connection with Cypress's integrated circuit products.
+ * Any reproduction, modification, translation, compilation, or representation
+ * of this Software except as specified above is prohibited without
+ * the expresswritten permission of Cypress.
+ * Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ * Cypress reserves the right to make changes to the Software without notice.
+ * Cypress does not assume any liability arising out of the application or
+ * use of the Software or any product or circuit described in the Software.
+ * Cypress does not authorize its products for use in any products where a malfunction
+ * or failure of the Cypress product may reasonably be expected to result in
+ * significant property damage, injury or death ("High Risk Product").
+ * By including Cypress's product in a High Risk Product, the manufacturer
+ * of such system or application assumes all risk of such use and in doing so
+ * agrees to indemnify Cypress against all liability.
+ */
+
+#ifndef BRCMF_TWT_H
+#define BRCMF_TWT_H
+
+#include "vendor_ifx.h"
+#include "core.h"
+
+/* Min TWT Default Unit */
+#define WAKE_DUR_UNIT_DEF 256
+/* Min TWT Unit in TUs */
+#define WAKE_DUR_UNIT_TU 1024
+
+/**
+ * enum brcmf_twt_cmd - TWT iovar subcmds handled by firmware TWT module
+ *
+ * @BRCMF_TWT_CMD_ENAB: Enable the firmware TWT module.
+ * @BRCMF_TWT_CMD_SETUP: Setup a TWT session with a TWT peer.
+ * @BRCMF_TWT_CMD_TEARDOWN: Teardown the active TWT session with a TWT peer.
+ */
+enum brcmf_twt_cmd {
+	BRCMF_TWT_CMD_ENAB,
+	BRCMF_TWT_CMD_SETUP,
+	BRCMF_TWT_CMD_TEARDOWN,
+};
+
+/* TWT iovar subcmd version */
+#define BRCMF_TWT_SETUP_VER	0u
+#define BRCMF_TWT_TEARDOWN_VER	0u
+
+/**
+ * enum brcmf_twt_flow_flag - TWT flow flags to be used in TWT iovar setup subcmd
+ *
+ * @BRCMF_TWT_FLOW_FLAG_BROADCAST: Broadcast TWT Session.
+ * @BRCMF_TWT_FLOW_FLAG_IMPLICIT: Implcit TWT session type.
+ * @BRCMF_TWT_FLOW_FLAG_UNANNOUNCED: Unannounced TWT session type.
+ * @BRCMF_TWT_FLOW_FLAG_TRIGGER: Trigger based TWT Session type.
+ * @BRCMF_TWT_FLOW_FLAG_WAKE_TBTT_NEGO: Wake TBTT Negotiation type.
+ * @BRCMF_TWT_FLOW_FLAG_REQUEST: TWT Session setup requestor.
+ * @BRCMF_TWT_FLOW_FLAG_RESPONDER_PM: Not used.
+ * @BRCMF_TWT_FLOW_FLAG_UNSOLICITED: Unsolicited TWT Session Setup.
+ * @BRCMF_TWT_FLOW_FLAG_PROTECT: Specifies whether Tx within SP is protected, Not used.
+ */
+enum brcmf_twt_flow_flag {
+	BRCMF_TWT_FLOW_FLAG_BROADCAST      = BIT(0),
+	BRCMF_TWT_FLOW_FLAG_IMPLICIT       = BIT(1),
+	BRCMF_TWT_FLOW_FLAG_UNANNOUNCED    = BIT(2),
+	BRCMF_TWT_FLOW_FLAG_TRIGGER        = BIT(3),
+	BRCMF_TWT_FLOW_FLAG_WAKE_TBTT_NEGO = BIT(4),
+	BRCMF_TWT_FLOW_FLAG_REQUEST        = BIT(5),
+	BRCMF_TWT_FLOW_FLAG_RESPONDER_PM   = BIT(6),
+	BRCMF_TWT_FLOW_FLAG_UNSOLICITED    = BIT(7),
+	BRCMF_TWT_FLOW_FLAG_PROTECT        = BIT(8)
+};
+
+/**
+ * struct brcmf_twt_params - TWT session parameters
+ *
+ * @twt_oper: TWT operation, Refer enum ifx_twt_oper.
+ * @negotiation_type: Negotiation Type, Refer enum ifx_twt_param_nego_type.
+ * @setup_cmd: Setup cmd, Refer enum ifx_twt_oper_setup_cmd_type.
+ * @dialog_token: TWT Negotiation Dialog Token.
+ * @twt: Target Wake Time.
+ * @twt_offset: Target Wake Time Offset.
+ * @min_twt: Nominal Minimum Wake Duration.
+ * @exponent: Wake Interval Exponent.
+ * @mantissa: Wake Interval Mantissa.
+ * @requestor: TWT Session requestor or responder.
+ * @implicit: implicit or Explicit TWT session.
+ * @flow_type: Announced or Un-Announced TWT session.
+ * @flow_id: Flow ID.
+ * @bcast_twt_id: Broadcast TWT ID.
+ * @protection: Protection, Not used.
+ * @twt_channel: TWT Channel, Not used.
+ * @twt_info_frame_disabled: TWT information frame disabled, Not used.
+ * @min_twt_unit: Nominal Minimum Wake Duration Unit.
+ * @teardown_all_twt: Teardown All TWT.
+ */
+struct brcmf_twt_params {
+	enum ifx_twt_oper twt_oper;
+	enum ifx_twt_param_nego_type negotiation_type;
+	enum ifx_twt_oper_setup_cmd_type setup_cmd;
+	u8 dialog_token;
+	u64 twt;
+	u64 twt_offset;
+	u8 min_twt;
+	u8 exponent;
+	u16 mantissa;
+	u8 requestor;
+	u8 trigger;
+	u8 implicit;
+	u8 flow_type;
+	u8 flow_id;
+	u8 bcast_twt_id;
+	u8 protection;
+	u8 twt_channel;
+	u8 twt_info_frame_disabled;
+	u8 min_twt_unit;
+	u8 teardown_all_twt;
+};
+
+/**
+ * enum brcmf_twt_wake_time_type - Type of the struct members wake_time_{h/l} in the
+ *	TWT Setup descriptor struct brcmf_twt_sdesc.
+ *
+ * @BRCMF_TWT_WAKE_TIME_TYPE_BSS: wake_time_{h/l} is the BSS TSF tiume.
+ * @BRCMF_TWT_WAKE_TIME_TYPE_OFFSET: wake_time_{h/l} is an offset of TSF time
+ *	when the iovar is processed.
+ * @BRCMF_TWT_WAKE_TIME_TYPE_AUTO: The target wake time is chosen internally by the Firmware.
+ */
+enum brcmf_twt_wake_time_type {
+	BRCMF_TWT_WAKE_TIME_TYPE_BSS,
+	BRCMF_TWT_WAKE_TIME_TYPE_OFFSET,
+	BRCMF_TWT_WAKE_TIME_TYPE_AUTO
+};
+
+/**
+ * struct brcmf_twt_sdesc - TWT Setup Descriptor.
+ *
+ * @setup_cmd: Setup command and event type. Refer enum ifx_twt_oper_setup_cmd_type.
+ * @flow_flags: Flow attributes, Refer enum brcmf_twt_flow_flag.
+ * @flow_id: Flow ID, Range 0-7. Set to 0xFF for auto assignment.
+ * @wake_type: wake_time_{h/l} type, Refer enum brcmf_twt_wake_time_type.
+ * @wake_time_h: Target Wake Time, high 32 bits.
+ * @wake_time_l: Target Wake Time, Low 32 bits.
+ * @wake_dur: Target Wake Duration in unit of uS.
+ * @wake_int: Target Wake Interval.
+ * @btwt_persistence: Broadcast TWT Persistence.
+ * @wake_int_max: Max Wake interval(uS) for TWT.
+ * @duty_cycle_min: Min Duty cycle for TWT(Percentage).
+ * @pad: 1 byte pad.
+ * @bid: Brodacst TWT ID, Range 0-31. Set to 0xFF for auto assignment.
+ * @channel: TWT channel - Not used.
+ * @negotiation_type: Negotiation Type, Refer enum ifx_twt_param_nego_type.
+ * @frame_recomm: Frame recommendation for broadcast TWTs - Not used.
+ */
+struct brcmf_twt_sdesc {
+	u8 setup_cmd;
+	u8 flow_flags;
+	u8 flow_id;
+	u8 wake_type;
+	u32 wake_time_h;
+	u32 wake_time_l;
+	u32 wake_dur;
+	u32 wake_int;
+	u32 btwt_persistence;
+	u32 wake_int_max;
+	u8 duty_cycle_min;
+	u8 pad;
+	u8 bid;
+	u8 channel;
+	u8 negotiation_type;
+	u8 frame_recomm;
+};
+
+/**
+ * struct brcmf_twt_setup_oper - TWT iovar Setup operation subcmd data to firmware TWT module
+ *
+ * @version: Structure version.
+ * @length: data length (starting after this field).
+ * @peer: TWT peer address.
+ * @pad: 2 byte Pad.
+ * @sdesc: TWT setup descriptor.
+ */
+struct brcmf_twt_setup_oper {
+	u16 version;
+	u16 length;
+	struct ether_addr peer;
+	u8 pad[2];
+	struct brcmf_twt_sdesc sdesc;
+};
+
+/**
+ * struct brcmf_twt_teardesc - TWT Teardown descriptor.
+ *
+ * @negotiation_type: Negotiation Type: Refer enum ifx_twt_param_nego_type.
+ * @flow_id: Flow ID: Range 0-7. Set to 0xFF for auto assignment.
+ * @bid: Brodacst TWT ID: Range 0-31. Set to 0xFF for auto assignment.
+ * @alltwt: Teardown all TWT sessions: set to 0 or 1.
+ */
+struct brcmf_twt_teardesc {
+	u8 negotiation_type;
+	u8 flow_id;
+	u8 bid;
+	u8 alltwt;
+};
+
+/**
+ * struct brcmf_twt_teardown_oper - TWT iovar Teardown operation subcmd data to firmware TWT module.
+ *
+ * @version: structure version.
+ * @length: data length (starting after this field).
+ * @peer: TWT peer address.
+ * @teardesc: TWT Teardown descriptor.
+ */
+struct brcmf_twt_teardown_oper {
+	u16 version;
+	u16 length;
+	struct ether_addr peer;
+	struct brcmf_twt_teardesc teardesc;
+};
+
+/**
+ * brcmf_twt_oper() - Handle the TWT Operation requests from Userspace.
+ *
+ * @wiphy: wiphy object for cfg80211 interface.
+ * @wdev: wireless device.
+ * @twt_params: TWT session parameters.
+ */
+int brcmf_twt_oper(struct wiphy *wiphy, struct wireless_dev *wdev,
+		  struct brcmf_twt_params twt_params);
+
+#endif /* BRCMF_TWT_H */
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/vendor_ifx.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/vendor_ifx.c
index 8079c632469b..a9c31c8d3c9c 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/vendor_ifx.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/vendor_ifx.c
@@ -36,6 +36,7 @@
 #include "fwil.h"
 #include "vendor_ifx.h"
 #include "xtlv.h"
+#include "twt.h"
 
 static int ifx_cfg80211_vndr_send_cmd_reply(struct wiphy *wiphy,
 					    const void  *data, int len)
@@ -54,211 +55,9 @@ static int ifx_cfg80211_vndr_send_cmd_reply(struct wiphy *wiphy,
 	return cfg80211_vendor_cmd_reply(skb);
 }
 
-/* Wake Duration derivation from Nominal Minimum Wake Duration */
-static inline u32
-ifx_twt_min_twt_to_wake_dur(u8 min_twt, u8 min_twt_unit)
-{
-	u32 wake_dur;
-
-	if (min_twt_unit == 1) {
-		/* If min_twt_unit is 1, then min_twt is
-		 * in units of TUs (i.e) 102400 usecs.
-		 */
-		wake_dur = (u32)min_twt * 102400;
-	} else if (min_twt_unit == 0) {
-		/* If min_twt_unit is 0, then min_twt is
-		 * in units of 256 usecs.
-		 */
-		wake_dur = (u32)min_twt * 256;
-	} else {
-		/* Invalid min_twt */
-		wake_dur = 0;
-	}
-
-	return wake_dur;
-}
-
-/* Wake Interval derivation from Wake Interval Mantissa & Exponent */
-static inline u32
-ifx_twt_float_to_uint32(u8 exponent, u16 mantissa)
-{
-	return (u32)mantissa << exponent;
-}
-
-int ifx_twt_setup(struct wireless_dev *wdev, struct ifx_twt twt)
-{
-	struct brcmf_cfg80211_vif *vif;
-	struct brcmf_if *ifp;
-	struct ifx_twt_setup val;
-	s32 err;
-
-	vif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);
-	ifp = vif->ifp;
-
-	memset(&val, 0, sizeof(val));
-	val.version = IFX_TWT_SETUP_VER;
-	val.length = sizeof(val.version) + sizeof(val.length);
-
-	/* Default values, Override Below */
-	val.desc.flow_flags = 0x0;
-	val.desc.wake_dur = 0xFFFFFFFF;
-	val.desc.wake_int = 0xFFFFFFFF;
-	val.desc.wake_int_max = 0xFFFFFFFF;
-
-	/* Setup command */
-	val.desc.setup_cmd = twt.setup_cmd;
-
-	/* Flow flags */
-	val.desc.flow_flags |= ((twt.negotiation_type & 0x02) >> 1 ?
-				IFX_TWT_FLOW_FLAG_BROADCAST : 0);
-	val.desc.flow_flags |= (twt.implicit ? IFX_TWT_FLOW_FLAG_IMPLICIT : 0);
-	val.desc.flow_flags |= (twt.flow_type ? IFX_TWT_FLOW_FLAG_UNANNOUNCED : 0);
-	val.desc.flow_flags |= (twt.trigger ? IFX_TWT_FLOW_FLAG_TRIGGER : 0);
-	val.desc.flow_flags |= ((twt.negotiation_type & 0x01) ?
-				IFX_TWT_FLOW_FLAG_WAKE_TBTT_NEGO : 0);
-	val.desc.flow_flags |= (twt.requestor ? IFX_TWT_FLOW_FLAG_REQUEST : 0);
-	val.desc.flow_flags |= (twt.protection ? IFX_TWT_FLOW_FLAG_PROTECT : 0);
-
-	if (twt.flow_id) {
-		/* Flow ID */
-		val.desc.flow_id = twt.flow_id;
-	} else if (twt.bcast_twt_id) {
-		/* Broadcast TWT ID */
-		val.desc.bid = twt.bcast_twt_id;
-	} else {
-		/* Let the FW choose the Flow ID, Broadcast TWT ID */
-		val.desc.flow_id = 0xFF;
-		val.desc.bid = 0xFF;
-	}
-
-	if (twt.twt) {
-		/* Target Wake Time parameter */
-		val.desc.wake_time_h = (u32)(twt.twt >> 32);
-		val.desc.wake_time_l = (u32)(twt.twt);
-		val.desc.wake_type = IFX_TWT_TIME_TYPE_BSS;
-	} else if (twt.twt_offset) {
-		/* Target Wake Time offset parameter */
-		val.desc.wake_time_h = (u32)(twt.twt_offset >> 32);
-		val.desc.wake_time_l = (u32)(twt.twt_offset);
-		val.desc.wake_type = IFX_TWT_TIME_TYPE_OFFSET;
-	} else {
-		/* Let the FW choose the Target Wake Time */
-		val.desc.wake_time_h = 0x0;
-		val.desc.wake_time_l = 0x0;
-		val.desc.wake_type = IFX_TWT_TIME_TYPE_AUTO;
-	}
-
-	/* Wake Duration or Service Period */
-	val.desc.wake_dur = ifx_twt_min_twt_to_wake_dur(twt.min_twt,
-							twt.min_twt_unit);
-	/* Wake Interval or Service Interval */
-	val.desc.wake_int = ifx_twt_float_to_uint32(twt.exponent,
-						    twt.mantissa);
-	/* TWT Negotiation_type */
-	val.desc.negotiation_type = (u8)twt.negotiation_type;
-	err = brcmf_fil_xtlv_data_set(ifp, "twt", IFX_TWT_CMD_SETUP,
-				      (void *)&val, sizeof(val));
-
-	brcmf_dbg(TRACE, "TWT setup\n"
-		"Setup command	: %u\n"
-		"Flow flags	: 0x %02x\n"
-		"Flow ID		: %u\n"
-		"Broadcast TWT ID	: %u\n"
-		"Wake Time H,L	: 0x %08x %08x\n"
-		"Wake Type		: %u\n"
-		"Wake Dururation	: %u usecs\n"
-		"Wake Interval	: %u usecs\n"
-		"Negotiation type	: %u\n",
-		val.desc.setup_cmd,
-		val.desc.flow_flags,
-		val.desc.flow_id,
-		val.desc.bid,
-		val.desc.wake_time_h,
-		val.desc.wake_time_l,
-		val.desc.wake_type,
-		val.desc.wake_dur,
-		val.desc.wake_int,
-		val.desc.negotiation_type);
-
-	if (err < 0)
-		brcmf_err("TWT setup failed. ret:%d\n", err);
-
-	return err;
-}
-
-int ifx_twt_teardown(struct wireless_dev *wdev, struct ifx_twt twt)
-{
-	struct brcmf_cfg80211_vif *vif;
-	struct brcmf_if *ifp;
-	struct ifx_twt_teardown val;
-	s32 err;
-
-	vif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);
-	ifp = vif->ifp;
-
-	memset(&val, 0, sizeof(val));
-	val.version = IFX_TWT_TEARDOWN_VER;
-	val.length = sizeof(val.version) + sizeof(val.length);
-
-	if (twt.flow_id) {
-		/* Flow ID */
-		val.teardesc.flow_id = twt.flow_id;
-	} else if (twt.bcast_twt_id) {
-		/* Broadcast TWT ID */
-		val.teardesc.bid = twt.bcast_twt_id;
-	} else {
-		/* Let the FW choose the Flow ID, Broadcast TWT */
-		val.teardesc.flow_id = 0xFF;
-		val.teardesc.bid = 0xFF;
-	}
-
-	/* TWT Negotiation_type */
-	val.teardesc.negotiation_type = (u8)twt.negotiation_type;
-	/* Teardown all Negotiated TWT */
-	val.teardesc.alltwt = twt.teardown_all_twt;
-	err = brcmf_fil_xtlv_data_set(ifp, "twt", IFX_TWT_CMD_TEARDOWN,
-				      (void *)&val, sizeof(val));
-
-	brcmf_dbg(TRACE, "TWT teardown\n"
-		"Flow ID		: %u\n"
-		"Broadcast TWT ID	: %u\n"
-		"Negotiation type	: %u\n"
-		"Teardown all TWT	: %u\n",
-		val.teardesc.flow_id,
-		val.teardesc.bid,
-		val.teardesc.negotiation_type,
-		val.teardesc.alltwt);
-
-	if (err < 0)
-		brcmf_err("TWT teardown failed. ret:%d\n", err);
-
-	return err;
-}
-
-int ifx_twt_oper(struct wireless_dev *wdev, struct ifx_twt twt)
-{
-	int ret = -1;
-
-	switch (twt.twt_oper) {
-	case IFX_TWT_OPER_SETUP:
-		ret = ifx_twt_setup(wdev, twt);
-		break;
-	case IFX_TWT_OPER_TEARDOWN:
-		ret = ifx_twt_teardown(wdev, twt);
-		break;
-	default:
-		brcmf_err("Requested TWT operation (%d) is not supported\n",
-			  twt.twt_oper);
-		ret = -EINVAL;
-		goto exit;
-	}
-exit:
-	return ret;
-}
-
 static void
 ifx_cfgvendor_twt_parse_params(const struct nlattr *attr_iter,
-			       struct ifx_twt *twt)
+			       struct brcmf_twt_params *twt_params)
 {
 	int tmp, twt_param;
 	const struct nlattr *twt_param_iter;
@@ -267,61 +66,61 @@ ifx_cfgvendor_twt_parse_params(const struct nlattr *attr_iter,
 		twt_param = nla_type(twt_param_iter);
 		switch (twt_param) {
 		case IFX_VENDOR_ATTR_TWT_PARAM_NEGO_TYPE:
-			twt->negotiation_type = nla_get_u8(twt_param_iter);
+			twt_params->negotiation_type = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_SETUP_CMD_TYPE:
-			twt->setup_cmd = nla_get_u8(twt_param_iter);
+			twt_params->setup_cmd = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_DIALOG_TOKEN:
-			twt->dialog_token = nla_get_u8(twt_param_iter);
+			twt_params->dialog_token = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_WAKE_TIME:
-			twt->twt = nla_get_u64(twt_param_iter);
+			twt_params->twt = nla_get_u64(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_WAKE_TIME_OFFSET:
-			twt->twt_offset = nla_get_u64(twt_param_iter);
+			twt_params->twt_offset = nla_get_u64(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_MIN_WAKE_DURATION:
-			twt->min_twt = nla_get_u8(twt_param_iter);
+			twt_params->min_twt = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_WAKE_INTVL_EXPONENT:
-			twt->exponent = nla_get_u8(twt_param_iter);
+			twt_params->exponent = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_WAKE_INTVL_MANTISSA:
-			twt->mantissa = nla_get_u16(twt_param_iter);
+			twt_params->mantissa = nla_get_u16(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_REQUESTOR:
-			twt->requestor = nla_get_u8(twt_param_iter);
+			twt_params->requestor = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_TRIGGER:
-			twt->trigger = nla_get_u8(twt_param_iter);
+			twt_params->trigger = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_IMPLICIT:
-			twt->implicit = nla_get_u8(twt_param_iter);
+			twt_params->implicit = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_FLOW_TYPE:
-			twt->flow_type = nla_get_u8(twt_param_iter);
+			twt_params->flow_type = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_FLOW_ID:
-			twt->flow_id = nla_get_u8(twt_param_iter);
+			twt_params->flow_id = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_BCAST_TWT_ID:
-			twt->bcast_twt_id = nla_get_u8(twt_param_iter);
+			twt_params->bcast_twt_id = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_PROTECTION:
-			twt->protection = nla_get_u8(twt_param_iter);
+			twt_params->protection = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_CHANNEL:
-			twt->twt_channel = nla_get_u8(twt_param_iter);
+			twt_params->twt_channel = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_TWT_INFO_FRAME_DISABLED:
-			twt->twt_info_frame_disabled = nla_get_u8(twt_param_iter);
+			twt_params->twt_info_frame_disabled = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_MIN_WAKE_DURATION_UNIT:
-			twt->min_twt_unit = nla_get_u8(twt_param_iter);
+			twt_params->min_twt_unit = nla_get_u8(twt_param_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAM_TEARDOWN_ALL_TWT:
-			twt->teardown_all_twt = nla_get_u8(twt_param_iter);
+			twt_params->teardown_all_twt = nla_get_u8(twt_param_iter);
 			break;
 		default:
 			brcmf_dbg(TRACE, "Unknown TWT param %d, skipping\n",
@@ -331,13 +130,13 @@ ifx_cfgvendor_twt_parse_params(const struct nlattr *attr_iter,
 	}
 }
 
-int ifx_cfg80211_vndr_cmds_twt(struct wiphy *wiphy,
-			       struct wireless_dev *wdev, const void  *data, int len)
+int ifx_cfg80211_vndr_cmds_twt(struct wiphy *wiphy, struct wireless_dev *wdev,
+			       const void  *data, int len)
 {
 	int tmp, attr_type;
 	const struct nlattr *attr_iter;
 
-	struct ifx_twt twt = {
+	struct brcmf_twt_params twt_params = {
 		.twt_oper = 0,
 		.negotiation_type = IFX_TWT_PARAM_NEGO_TYPE_ITWT,
 		.setup_cmd = IFX_TWT_OPER_SETUP_CMD_TYPE_REQUEST,
@@ -362,10 +161,10 @@ int ifx_cfg80211_vndr_cmds_twt(struct wiphy *wiphy,
 
 		switch (attr_type) {
 		case IFX_VENDOR_ATTR_TWT_OPER:
-			twt.twt_oper = nla_get_u8(attr_iter);
+			twt_params.twt_oper = nla_get_u8(attr_iter);
 			break;
 		case IFX_VENDOR_ATTR_TWT_PARAMS:
-			ifx_cfgvendor_twt_parse_params(attr_iter, &twt);
+			ifx_cfgvendor_twt_parse_params(attr_iter, &twt_params);
 			break;
 		default:
 			brcmf_dbg(TRACE, "Unknown TWT attribute %d, skipping\n",
@@ -374,7 +173,7 @@ int ifx_cfg80211_vndr_cmds_twt(struct wiphy *wiphy,
 		}
 	}
 
-	return ifx_twt_oper(wdev, twt);
+	return (int)brcmf_twt_oper(wiphy, wdev, twt_params);
 }
 
 int ifx_cfg80211_vndr_cmds_bsscolor(struct wiphy *wiphy,
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/vendor_ifx.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/vendor_ifx.h
index f71312111587..b9b57d5cfe06 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/vendor_ifx.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/vendor_ifx.h
@@ -433,21 +433,6 @@ enum ifx_twt_oper_setup_cmd_type {
 	IFX_TWT_OPER_SETUP_CMD_TYPE_MAX		= 8
 };
 
-/* TWT top level command IDs */
-enum {
-	IFX_TWT_CMD_ENAB = 0,
-	IFX_TWT_CMD_SETUP = 1,
-	IFX_TWT_CMD_TEARDOWN = 2,
-	IFX_TWT_CMD_INFO = 3,
-	IFX_TWT_CMD_AUTOSCHED = 4,
-	IFX_TWT_CMD_STATS = 5,
-	IFX_TWT_CMD_EARLY_TERM_TIME = 6,
-	IFX_TWT_CMD_RESP_CONFIG = 7,
-	IFX_TWT_CMD_SPPS_ENAB = 8,
-	IFX_TWT_CMD_FEATURES = 9,
-	IFX_TWT_CMD_LAST
-};
-
 /**
  * HE top level command IDs
  */
@@ -544,91 +529,6 @@ static const struct nla_policy ifx_vendor_attr_twt_policy[IFX_VENDOR_ATTR_TWT_MA
 	[IFX_VENDOR_ATTR_TWT_MAX] = {.type = NLA_U8},
 };
 
-struct ifx_twt {
-	u8 twt_oper;
-	enum ifx_twt_param_nego_type negotiation_type;
-	enum ifx_twt_oper_setup_cmd_type setup_cmd;
-	u8 dialog_token;
-	u64 twt;
-	u64 twt_offset;
-	u8 min_twt;
-	u8 exponent;
-	u16 mantissa;
-	u8 requestor;
-	u8 trigger;
-	u8 implicit;
-	u8 flow_type;
-	u8 flow_id;
-	u8 bcast_twt_id;
-	u8 protection;
-	u8 twt_channel;
-	u8 twt_info_frame_disabled;
-	u8 min_twt_unit;
-	u8 teardown_all_twt;
-};
-
-/* NOTES:
- * ifx_twt_sdesc is used to support both broadcast TWT and individual TWT.
- * Value in bit[0:2] in 'flow_id' field is interpreted differently:
- * - flow id for individual TWT (when IFX_TWT_FLOW_FLAG_BROADCAST bit is NOT set
- *   in 'flow_flags' field)
- * - flow id as defined in Table 8-248l1 for broadcast TWT (when
- *   IFX_TWT_FLOW_FLAG_BROADCAST bit is set)
- * In latter case other bits could be used to differentiate different flows
- * in order to support multiple broadcast TWTs with the same flow id.
- */
-
-/* TWT Setup descriptor */
-struct ifx_twt_sdesc {
-	/* Setup Command. */
-	u8 setup_cmd;		/* See TWT_SETUP_CMD_XXXX in 802.11ah.h */
-	u8 flow_flags;		/* Flow attributes. See WL_TWT_FLOW_FLAG_XXXX below */
-	u8 flow_id;		/* must be between 0 and 7. Set 0xFF for auto assignment */
-	u8 wake_type;	/* See WL_TWT_TIME_TYPE_XXXX below */
-	u32 wake_time_h;	/* target wake time - BSS TSF (us) */
-	u32 wake_time_l;
-	u32 wake_dur;	/* target wake duration in unit of microseconds */
-	u32 wake_int;	/* target wake interval */
-	u32 btwt_persistence;	/* Broadcast TWT Persistence */
-	u32 wake_int_max;	/* max wake interval(uS) for TWT */
-	u8 duty_cycle_min;	/* min duty cycle for TWT(Percentage) */
-	u8 pad;
-	u8 bid;		/* must be between 0 and 31. Set 0xFF for auto assignment */
-	u8 channel;		/* Twt channel - Not used for now */
-	u8 negotiation_type;	/* Negotiation Type: See macros TWT_NEGO_TYPE_X */
-	u8 frame_recomm;	/* frame recommendation for broadcast TWTs - Not used for now	 */
-};
-
-/* twt teardown descriptor */
-struct ifx_twt_teardesc {
-	u8 negotiation_type;
-	u8 flow_id;		/* must be between 0 and 7 */
-	u8 bid;		/* must be between 0 and 31 */
-	u8 alltwt;		/* all twt teardown - 0 or 1 */
-};
-
-/* HE TWT Setup command */
-struct ifx_twt_setup {
-	/* structure control */
-	u16 version;	/* structure version */
-	u16 length;	/* data length (starting after this field) */
-	/* peer address */
-	struct ether_addr peer;	/* leave it all 0s' for AP */
-	u8 pad[2];
-	/* setup descriptor */
-	struct ifx_twt_sdesc desc;
-};
-
-/* HE TWT Teardown command */
-struct ifx_twt_teardown {
-	/* structure control */
-	u16 version;	/* structure version */
-	u16 length;	/* data length (starting after this field) */
-	/* peer address */
-	struct ether_addr peer;	/* leave it all 0s' for AP */
-	struct ifx_twt_teardesc teardesc;	/* Teardown descriptor */
-};
-
 /* randmac define/enum/struct
  */
 #define WL_RANDMAC_API_VERSION		0x0100 /**< version 1.0 */
-- 
2.17.1

